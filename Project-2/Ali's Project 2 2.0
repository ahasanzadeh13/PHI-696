# Project 2

Your second project will require you to answer each of the 10 questions below.  You will be expected to open a pull request with your initial answers by the second class meeting, giving you one week to work on these problems. You and your peers will then have one week to work together to refine your respective initial answers, so they are ready for final submission. Once your pull requests have been reviewed and merged to the development branch, I will review them, then merge to the master branch. 

```
Tip #1: Carefully study the Baader, et. al. selections assigned on bisimulation; it is deceptively subtle, and quite powerful. 
Tip #2: Google is still your friend. So is stackexchange...
Tip #3: Work _together_ to solve these problems, even for initial submissions and when you do, document this in github. 
Tip #4: Work together _as a team_. 
```

1. Let V be a vocabulary of ALCI consisting of a role name "P". Interpret part_of as "x is a part of y". Using this role name, define the following formulas in this language:
```
  (a)  PP that says that x is a proper part of y

	PP := P ⊓ (¬P¯) 

  (b)  iPP that says that y is a proper part of x

	iPP := PP¯ =>
    iPP ≡ (P ⊓ ¬P¯)¯

    iPP ≡ ¬P ⊓ P¯

    These are equivalent.

  (c)  iP that says that y has x as part 

	iP := P¯

  (d)  O that says that x overlaps y

    O := ∃P¯.(∃P)
	O := ∃iP.(∃P.⊤)


  (e)  D that says that x and y are disjoint 

	D := ¬O

```

2. Use your axioms from question 1 as the basis of an ALCI T-Box. Supplement this T-box with whatever other axioms you like, as well as an A-box, so that you ultimately construct a knowledge base K = (T,A). Provide a _model_ of K. This may be graphical or symbolic or both. 

  T-Box:
  {
    PP ⊑ P
    iPP ⊑ iP
    P ⊑ O
    O ⊑ O¯
    O¯ ⊑ O
    D ⊑ ¬O
    }
  
  A-Box:
  { 
    (Washington, USA) : P
    (Seattle, Washington) : PP
    (Seattle, USA) : PP
    (USA, Washington) : iPP
    (Washington, USA) : O
    (New York, Washignton) : D
   
    }

  ΔI = {Seattle, Washington, New York, USA}

  Named Individuals:
  Seattle = S,
  Washinton = W,
  New York = N,
  USA = U

  Role Assignments:
    P = {(S, W), (S, U), (W, U), (N, U), (S, S), (W, W), (N, N), (U, U)}
    PP = {(S, W), (S, U), (W, U), (N, U)}
    iP = {(W, S), (U, S), (U, W), (U, N), (S, S), (W, W), (N, N), (U, U)}
    iPP = {(W, S), (U, S), (U, W), (U, N)}
    O = {(S, W), (S, U), (W, U), (N, U), (S, S), (W, W), (N, N), (U, U)}
    D = {(S, N), (W, N)}


3. Translate the following first-order logic axioms into ALCI:
   ```
   (a) ∀x∃y∀z(R(x,y) ∧ R(x,z) ∧ R(y,z))

    ∃R.(∀R.T) ⊓ ∀R.T
    The "T" is used as the Tautology which plays the role of a unit concept.
    The unit concept means that when applied, it does not change anything about the description.
    This is done so that we can change from Universal Quantifier to Existential Quantifier. 


   (b) ∃x∀y∃z(R(x,y) ∧ R(x,z) ∧ R(y,z))

    ∃R¯(∃R.T) ⊓ ∃R(T)
    The easiest way to do this is to have x and z to be successors of y.
    So, it is best to write R(x,y) as R¯(y,x)

   (c) ∀y(R(x, y) → ∃x(R(y, x) ∧ ∀y(R(x, y) → A(y))))
    
    ∀R.∃R.∀R.A
    We need not to be concernd with R(y, x) since y is closed.

   (d) (∀y)(R(x, y) → A(y)) ∧ (∃y)(R(x, y) ∧ B(y))

   (∀R.A) ⊓ (∃R.B)

   ```

4. Provide an interpretation I<sub>1</sub> for ALC and an interpretation I<sub>2</sub> for ALCN - each distinct from any 
interpretation covered in class so far - and construct a bisimulation that demonstrates ALCN is more expressive than ALC. 
Use the [mermaid syntax](https://github.com/mermaid-js/mermaid) of markdown to provide a graphical representation of your work. 

  ```

   We find cases in which two different bisimiulations would be distinguishable by ALCN, but not ALC.

   P = Professor
   P ⊓ ∃R.T (ALC interpretation cannot distinguish between numbers of successors)

   P ⊓ ≥ 2R.T(ALCN Interpretation)
   P ⊓ ≥ 3R.T(ALCN Interpretation)

   The Following link is the ALCN Mermaid Diagram: (https://mermaid.ink/img/pako:eNqNkDELwjAUhP9KeIsV6mALihkcpC5OgkIH4_BInqbYJiVNlWL7363oIA7am2747jjuDtIqAg6n3N6kRufZPhGG9Uqmh43Vhq3oSi5vjmwyWbLWE0pNVcvW02Crs9liPh6GR088jhYD8ThISRmqFDYste5SaVu-osK8G6LfDaPvgf_4j4UQQkGuwEz119yfeQFeU0ECeG8VuosAYbqew9rbXWMkcO9qCqEuFXpKMjw7LICfMK-oewBlPXJD?type=png)](https://mermaid.live/edit#pako:eNqNkDELwjAUhP9KeIsV6mALihkcpC5OgkIH4_BInqbYJiVNlWL7363oIA7am2747jjuDtIqAg6n3N6kRufZPhGG9Uqmh43Vhq3oSi5vjmwyWbLWE0pNVcvW02Crs9liPh6GR088jhYD8ThISRmqFDYste5SaVu-osK8G6LfDaPvgf_4j4UQQkGuwEz119yfeQFeU0ECeG8VuosAYbqew9rbXWMkcO9qCqEuFXpKMjw7LICfMK-oewBlPXJD)

   ΔI1 = {Dr. Beverley, PHI 697, PHI 329, Tuesday Workshop}

   Named IndividualsI:
    Dr. BeverleyI = B
    PHI 697I = 697
    PHI 329I = 329
    Tuesday WorkshopI = W

    Role Assignments:
    t = {(B, 697), (B, 329), (B, W)}

    The Following link is the ALC Mermaid Diagram: (https://mermaid.ink/img/pako:eNqNjzELwjAQhf9KuEWFOrSC0g4OUhcnQTfjcCSnKTaJxFQpbf-7KXUQB_VNx_F9PF4DwkqCDE6lfQiFzrN9zg0LyePDxirDVnQnV9ZHNp0uWesJhaJby9bxeKuKebqY_IcnPT5L0gF_Ocl3Z_TZ8Yt_K4EINDmNhQzrmt7n4BVp4pCFU6K7cOCmCxxW3u5qIyDzrqIIqqtET3mBZ4d6eHZPfdldeA?type=png)](https://mermaid.live/edit#pako:eNqNjzELwjAQhf9KuEWFOrSC0g4OUhcnQTfjcCSnKTaJxFQpbf-7KXUQB_VNx_F9PF4DwkqCDE6lfQiFzrN9zg0LyePDxirDVnQnV9ZHNp0uWesJhaJby9bxeKuKebqY_IcnPT5L0gF_Ocl3Z_TZ8Yt_K4EINDmNhQzrmt7n4BVp4pCFU6K7cOCmCxxW3u5qIyDzrqIIqqtET3mBZ4d6eHZPfdldeA)
    
    ΔI2 = {Dr. Beverley, PHI 697, PHI 329}

    Named IndividualsI:
    Dr. BeverleyI2 = B2
    PHI2 697I = 697-2
    PHI 329I = 329-2

    Role Assignments:
    t2 = {(B2, 697-2),  (B, 329-2)}

    Bisimulation:

    ρ = {(B, B2), (697, 697-2), (329, 329-2)}

    So B is bisimilar to B2. But we can distinguish them in ALCN by defining the role t as
    ≥3 ∃t.⊤
    in I1
    ≥2 ∃t2.⊤
    in I2
    
   ![Q4_1](https://user-images.githubusercontent.com/106703400/221631419-7faaae44-c4ba-4135-b6ca-9e1476bd2995.png)
   ![Q4_2](https://user-images.githubusercontent.com/106703400/221631421-b3bfe0c8-4f85-43d8-8ccf-c7c5148a65a8.png)

    
  ```

5. Provide an interpretation I<sub>1</sub> for ALC and an interpretation I<sub>2</sub> for ALCN - each distinct from any 
interpretation covered in class so far - and construct a bisimulation that _does not_ demonstrate ALCN is more expressive than ALC. 
Use the [mermaid syntax](https://github.com/mermaid-js/mermaid) of markdown to provide a graphical representation of your work. 

  ```

These graphical representations do not demonstrate that ALCN is more expressive than ALC.

The Following link is both the ALC and ALCN Mermaid Diagram:(https://mermaid.ink/img/pako:eNqNjzELwjAQhf9KuEWFOrSC0g4OUhcnQTfjcCSnKTaJxFQpbf-7KXUQB_VNx_F9PF4DwkqCDE6lfQiFzrN9zg0LyePDxirDVnQnV9ZHNp0uWesJhaJby9bxeKuKebqY_IcnPT5L0gF_Ocl3Z_TZ8Yt_K4EINDmNhQzrmt7n4BVp4pCFU6K7cOCmCxxW3u5qIyDzrqIIqqtET3mBZ4d6eHZPfdldeA?type=png)](https://mermaid.live/edit#pako:eNqNjzELwjAQhf9KuEWFOrSC0g4OUhcnQTfjcCSnKTaJxFQpbf-7KXUQB_VNx_F9PF4DwkqCDE6lfQiFzrN9zg0LyePDxirDVnQnV9ZHNp0uWesJhaJby9bxeKuKebqY_IcnPT5L0gF_Ocl3Z_TZ8Yt_K4EINDmNhQzrmt7n4BVp4pCFU6K7cOCmCxxW3u5qIyDzrqIIqqtET3mBZ4d6eHZPfdldeA)

ΔI1 = {John Beverley, PHI 697, PHI 329}

Named IndividualsI:
Dr. BeverleyI = B
PHI 697I = 697
PHI 329I = 329
Tuesday WorkshopI = W

Role Assignments:
t = {(B, 697), (B, 329), (B, W)}


ΔI2 = {Dr. Beverley, PHI 697, PHI 329}

Named IndividualsI:
Dr. BeverleyI2 = B2
PHI2 697I = 697-2
PHI 329I = 329-2

Role Assignments:
t2 = {(B2, 697-2),  (B, 329-2)}

Bisimulation:

ρ = {(B, B2), (697, 697-2), (329, 329-2)}

So B is bisimilar to B2. The ALCN definitions are
≥2 ∃m.⊤
in I1
≥2 ∃m2.⊤
in I2

![Q5_1](https://user-images.githubusercontent.com/106703400/221631249-08c1618e-0103-425f-bbad-f2c9d27584f3.png)
![Q5_2](https://user-images.githubusercontent.com/106703400/221631253-646b4702-61ee-412b-935c-28f404ae9b41.png)


  ```

6. Explain the difference - using natural language - between the first-order prefixes:
  ```
  (a) ∃r.C and ∀r.C

    The first one reads (equivalent to in first-order logic: ∀x∃y(r(x,y)∧Cy)):
    all x has a r-filler y instantiating C
    The second one reads(equivalent to in first-order logic: ∀x∀y(r(x,y)→Cy)):
    all r-fillers ys of all x instantiate C.

  (b) ∃r-.C and ∀r-.C 

 The first one reads(equivalent to in first-order logic: ∀x∃y(r-(x,y)∧Cy), or ∀x∃y(r(y,x)∧Cy)):
    there is a thing y r-related to all xs, (or, all xs are r-inverse-related to y) and this thing falls under concept C
 The second one reads(equivalent to in first-order logic: ∀x∀y(r-(x,y)→Cy), or ∀x∀y(r(y,x)→Cy)):
    if there is a thing r-related to all xs, (or, all xs are r-inverse-related to all ys) this thing falls under concept C

  (c) <=nr and <=nr.C

    The first one reads: role r connects all the xs to no more than n elements.
    The second one reads: role r connects all the xs to no more than n elements, and they fall under concept C.

  (d) ∃r-.C and ∃r-.{a}

  
    The first one reads(equivalent to in first-order logic: ∀x∃y(r-(x,y)∧Cy), or ∀x∃y(r(y,x)∧Cy)):
    for all xs, there is at least a thing y, which is r-related to it, and which falls under concept C.

    The second one reads(equivalent to in first-order logic: ∀x∃y(r-(x,y)∧(y=a)), or ∀x∃y(r(y,x)∧(y=a))):
    for all xs, there is element a, which is r-related to it.

   ```

7. There is a delightfully helpful subreddit called "ELI5" which stands for something like "explain it like I'm 5" where users post conceptually challenging 
questions and other users attempt to provide explanations in simple, jargon-free, terms that presumably a 5 year-old could understand. Using this as a model,
explain the _finite model property_. Be sure to provide a simple example and explain when the property might be important, and when it is not so important. 

The finite model property means that if you want to prove something in a game or puzzle, you don't have to use too many toys or blocks, just a few of them will be enough. 
This makes it easier to solve the game or puzzle and saves time.

The Example:

Suppose you have a game with two toy animals, a cat and a dog. The rules of the game are that the cat is always hungry, and the dog is always friendly.
You want to prove that if the cat is hungry, then the dog is not hungry. One way to prove this would be to use all the possible combinations of hunger and 
friendliness for the cat and the dog, which would require an infinite number of possibilities. But because the game has the finite model property, we can 
prove it using only the two animals we have.
So we can set up the game like this: put the cat and the dog in front of you, and give the cat a label that says "hungry". Now, because the game has the 
finite model property, we can prove that if the cat is hungry (which it is, according to the rules), then the dog is not hungry (because the dog is always 
friendly, and there is no rule that says friendly animals are also hungry).
In this example, we were able to use only the two animals we had to prove something about the game, instead of needing an infinite number of animals. 
This is an illustration of the finite model property in action.

8. Following up on the preceding , explain the _tree model property_. Be sure to provide a simple example and explain when the property might be important, and when it is not so important. 

Imagine you have a toy with lots of buttons and levers. When you press a button or pull a lever, the toy changes in some way. The finite tree model is like a picture of all the different ways the toy can change.
Each picture shows the toy in a different state, with some buttons and levers pressed and others not pressed. The lines between the pictures show how the toy changes when you press a button or pull a lever.
By looking at all the pictures together, you can see all the different ways the toy can change, and how it changes from one state to another. This can help you understand how the toy works and how to use it.
In the same way, the finite tree model helps people understand how programs and processes work by showing all the different ways they can change and how they change from one state to another.
An example:Imagine you're playing a game where you have to guess a number between 1 and 10. The game will tell you if your guess is too high or too low, and you have to keep guessinguntil you get the right answer.
We can represent this game as a finite tree model. The starting point is when you make your first guess, which is like the "root" of the tree. Depending on whether your guess is too high or too low, the tree branches off into two different paths.
If your guess is too high, you go down one path where you make a lower guess. If your guess is too low, you go down the other path where you make a higher guess.
This branching continues until you finally guess the right number, which is like reaching a "leaf" node in the tree.
By using the finite tree model to represent the guessing game, we can see all the different possible paths that the game can take, and how the game progresses from one guess to the next.
In the same way, the finite tree model helps people understand how programs and processes work by showing all the different ways they can change and how they change from one state to another.

9. Open the Protege editor and create object properties for each of the role names that you constructed in question 1. You should have at least 6 object properties.
Assert in the editor that P is a sub-property of O, that P is transitive, and that O is symmetric. Next, add individuals - a, b, c - to the file and assert that c 
is part of a and that c overlaps b. Running the reasoner should reveal - highlighted in yellow if you select the individual c - that c overlaps a. Using the discussion 
in the selections from chapter 4 of the Baader, et. al. text as a guide, explain how the tableau algorithm is generating this inference. 

```
  The tableau method starts from a Knowledge Base, i.e. the assertions we made through the Protege editor about individuals and between
  classes. We then build a tree. Each node in the tree represents a possible interpretation, and the branches represent the different
  ways in which the interpretation can be extended. It then expands the assertions by using different rules. For example the disjunction
  rule to check all the possible cases (see Baader from page 71 to 73) and other rules for subsumption, etc. (see Baader pag. 84).
  What we are doing is basically constructing a set of possible interpretations where all the possible inferences from T-box are drawn,
  as well as all the possible concept memberships are tried.
  As a result, the reasoner will notice the logical relations between the concepts we asserted for individuals through Protege.
  It will see that c is a part of a, and since parthood is subsumed by overlap, it will apply the subsumption rule explained at
  page 84 in Baader et al. This will add a new fact, that c overlaps a. 

```

10. Following up on your work in question 9, adjust/add/remove/etc. object properties and individuals in your Protege file so that when you run a reasoner in Protege, you return the following consequences: 
```
  (a) a is a proper part of b and disjoint from e
  (b) a overlaps c
  (c) a is part of b, b is part of f, and a is part of f
  (e) There are no parts between a and g in common
  
![Screenshot_20230227_114619](https://user-images.githubusercontent.com/106703400/221627164-2f6dc5aa-282f-46ff-a77f-0182d6d8a02c.png)
![Screenshot_20230227_114640](https://user-images.githubusercontent.com/106703400/221627166-6b58c0d4-1714-4b08-b3b3-b60d6dbc41c6.png)
![Screenshot_20230227_114717](https://user-images.githubusercontent.com/106703400/221627168-7d944fed-61f5-4a56-a142-b9456b29b80c.png)
![Screenshot_20230227_114733](https://user-images.githubusercontent.com/106703400/221627169-b07cd4eb-4c90-4c8b-a38b-45ba499da664.png)
![Screenshot_20230227_114747](https://user-images.githubusercontent.com/106703400/221627170-8c5c22fc-cf96-4b0d-8d60-8a518effa15b.png)
![Screenshot_20230227_114759](https://user-images.githubusercontent.com/106703400/221627171-9b48b8d9-7b13-4bc7-b29e-3157f926597a.png)
![Screenshot_20230227_114858](https://user-images.githubusercontent.com/106703400/221627173-4c1f0959-960d-430c-a065-cb624815c469.png)
```
